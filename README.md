# DS1307 for the TEC-1
The DS1307 is a versatile and reliable chip for timekeeping applications, and its simplicity makes it popular in embedded systems and microcontroller applications to keep track of time and date information. It operates using an I2C interface and provides a way to maintain timekeeping even when the main system power is off, thanks to its battery backup feature. Here's an overview of its key features and functionalities:

### Key Features of the DS1307
1. **Timekeeping**:
   - The DS1307 can keep track of seconds, minutes, hours, day, date, month, and year, including leap year compensation (valid up to the year 2100).
   - It uses a 24-hour or 12-hour format with an AM/PM indicator.

2. **I2C Interface**:
   - The DS1307 communicates with microcontrollers using the I2C protocol, a two-wire interface (SDA for data and SCL for the clock).
   - The I2C address for the DS1307 is `0x68`, which is used to communicate with the RTC module.

3. **Battery Backup**:
   - The DS1307 has a pin for an external battery (typically a 3V coin cell) that allows it to keep time even when the main system power is off.
   - The clock continues to run as long as the battery is connected, making it suitable for timekeeping even during power loss.

4. **Square Wave Output**:
   - The DS1307 includes an output pin that can be configured to generate a square wave signal at frequencies of 1 Hz, 4.096 kHz, 8.192 kHz, or 32.768 kHz.

5. **RAM**:
   - It includes 56 bytes of non-volatile RAM that can be used for storing small amounts of data that need to persist through power cycles.

### DS1307 Registers
The DS1307 has a series of registers to store time, date, control settings, and RAM data:
- **Time Registers**: Store seconds, minutes, hours, day of the week, date, month, and year. These are in BCD (Binary Coded Decimal) format.
- **Control Register**: Used to configure the square wave output frequency or disable it.
- **RAM Registers**: Accessible via the I2C interface, allowing the user to store additional data.

### Common Uses
- **Clock and Calendar Functionality**: Often used in clocks, data loggers, and applications that require time stamps.
- **Alarms and Event Triggers**: Combined with a microcontroller, it can trigger events based on specific time and date settings.
- **Low-Power Applications**: Suitable for devices that need to maintain accurate timekeeping with minimal power consumption.

### Example I2C Communication with the DS1307
The microcontroller typically communicates with the DS1307 via I2C to:
- **Read**: The time and date information by accessing the appropriate registers.
- **Write**: The initial time and date setup or to modify timekeeping settings.

### Sample Pseudocode for Interfacing with DS1307
1. **Initialize the I2C bus**.
2. **Set the DS1307 time** (only if the RTC is not yet set):
   - Write to the time registers (hours, minutes, seconds, etc.) using I2C.
3. **Read the time**:
   - Access the time registers to retrieve and decode the current time and date.
4. **Configure the square wave output** (if needed):
   - Write the appropriate value to the control register.

## **I2C (Inter-Integrated Circuit)** protocol 
is a popular serial communication protocol used for connecting low-speed peripherals to microcontrollers. It operates using two lines: **SDA (Serial Data)** and **SCL (Serial Clock)**. Here’s a summary:

### Basic Features
1. **Two-Wire Interface**:
   - **SDA**: Carries the data.
   - **SCL**: Carries the clock signal generated by the master.
   
2. **Master-Slave Communication**:
   - The **master** device (typically a microcontroller) initiates communication and controls the clock.
   - The **slave** devices (like sensors, RTC modules, etc.) respond to the master's commands.
   
3. **Addressing**:
   - Each slave device on the I2C bus has a unique **7-bit** or **10-bit** address.
   - The master sends the address to communicate with a specific slave.

### I2C Protocol Basics
1. **Start Condition**:
   - The master pulls **SDA** low while **SCL** is high, indicating the start of communication.
   
2. **Slave Address and R/W Bit**:
   - The master sends the **7-bit address** of the target slave, followed by a **R/W bit**:
     - `0` for write (master sends data to slave).
     - `1` for read (master reads data from slave).
   - The slave acknowledges (ACK) by pulling SDA low.

3. **Data Transfer**:
   - The master and slave exchange 8-bit data packets:
     - The sender places the data on the SDA line while the clock is generated on SCL.
     - The receiver acknowledges each byte by pulling SDA low after each byte.

4. **Stop Condition**:
   - The master releases **SDA** while **SCL** is high, signaling the end of communication.

### Communication Sequence
1. **Start Condition**.
2. **Address Frame** (7-bit address + R/W bit).
3. **ACK/NACK** from the slave.
4. **Data Frame(s)** (master or slave sends data).
5. **ACK/NACK** after each data frame.
6. **Stop Condition**.

### Common I2C Operations
1. **Writing Data**:
   - Master sends the start condition, address, and write command.
   - Master sends register address and data.
   - Master sends the stop condition.
   
2. **Reading Data**:
   - Master sends the start condition, address, and write command.
   - Master sends the register address and restarts the bus.
   - Master sends the address with the read command and reads data from the slave.
   - Master sends the stop condition.

### Advantages
- **Simplicity**: Requires only two lines for multiple devices.
- **Scalability**: Supports multiple devices on the same bus (multi-master and multi-slave).
- **Low Cost**: Ideal for integrating low-speed peripherals like sensors, RTCs, and EEPROMs.

### MINT manage the two ports required for I2C (SDA and SCL), 
- it depends on the implementation
- and how the tec1 or hardware supports MINT operations.
- MINT needs to access and manipulate these two ports directly for I2C communication,
- which typically involves:

1. **Controlling the Clock Line (SCL)**:
   - MINT must be able to toggle the SCL line (set it high and low) to generate the clock pulses required for synchronization between the master and slave devices.

2. **Controlling the Data Line (SDA)**:
   - MINT must also control the SDA line to send and receive data bits.
   - It should be capable of configuring SDA as either an input (for reading data) or output (for sending data), as I2C is bidirectional.

### Requirements for MINT to Control I2C Ports
1. **Direct Port Access**:
   - MINT should have the ability to directly access the microcontroller’s GPIO ports associated with the SDA and SCL lines.
   - For example, MINT should support commands that can set a port high or low (for clock generation and data transfer).

2. **Bit Manipulation Capabilities**:
   - MINT must handle bit-level operations, such as shifting and masking, to construct data packets and control the timing precisely.

3. **I2C-Specific Routines**:
   - MINT needs routines for:
     - Generating the start and stop conditions.
     - Sending and receiving bits (acknowledgment bits, data bits).
     - Managing the read/write direction of the SDA line.

### Example Considerations for MINT Code
- To implement I2C in MINT, you would typically define functions to:
  - **Set SDA/SCL High or Low**.
  - **Generate a Clock Pulse** by toggling the SCL line.
  - **Send Data** by writing bits to the SDA line while toggling SCL.
  - **Read Data** by reading the SDA line while toggling SCL.



### Ref
- https://www.facebook.com/groups/623556744820045/search/?q=RTC
- we need i2c to control it https://github.com/SteveJustin1963/tec-I2C-SPI
  


